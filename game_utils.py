# Aaron Matayka
# Andrew Matayka
# 03/13/25
# Main Utility File for holding shared functions such as
# generating the grid, moving players, checking meet conditions, displaying statistics, etc
#
from player import Player
import time

# Simple function to make a grid based on the x_size and y_size,
# and if not declared makes a 2x2 grid
def make_grid(x_size = 2, y_size = 2):
    grid = []

    for _ in range(y_size):
        grid.append([0 for _ in range(x_size)])

    return grid

# Simple function used for printing any grid generated by make_grid.
# Uses *row to print without brackets for cleaner visualization
def print_grid(grid):
    for row in grid:
        print(*row)
    print()

# Function used to place players on the grid, defaulting to 2 players and the
# top left and bottom right corner of the grid. Can also input direct positions
# on the grid instead to position each character
def place_players(grid, players=2, positions=None):
    x_size = len(grid[0])
    y_size = len(grid)
    player_objects = []

    if positions is None:
        positions = [(0, 0), (y_size - 1, x_size - 1)] if players == 2 else []

    for i in range(players):
        if i < len(positions):
            y, x = positions[i]
            if 0 <= y < y_size and 0 <= x < x_size:
                player = Player(i + 1, (y, x))
                grid[y][x] = player.number
                player_objects.append(player)
            else:
                print(f"Invalid position for player {i + 1}: {(y, x)}")
        else:
            print(f"Warning: Not enough positions for {players} players.")

    return player_objects

#Function used to check if two players are on the same spot, and if so print this and return true.
def check_collision(player):
    player_positions = set()
    for player in players:
        if player.position in player_positions:
            print("Collision detected!")
            return True #Collision detected
        player_positions.add(player.position)
    print("No collision detected!")
    return False #No collision
# Testing code
test_grid = make_grid(5, 3)
print_grid(test_grid)

players = place_players(test_grid)
print_grid(test_grid)

# Run a loop to move the player randomly multiple times
for _ in range(25):  # Move 10 times
    if players:
        players[0].move("random", test_grid)
        players[1].move("random", test_grid)
    print_grid(test_grid)

    if check_collision(players):
        print("Players have met! Stopping simulation.")
        break
    time.sleep(0.5)  # Pause for half a second to visualize changes


# TODO: move test code at bottom to main
# TODO: Make 3 different py files, one for each scenario we have to implement: K-2, 3-5, and 6-8
# TODO: For each scenario, music needs to play during gameplay.
# TODO: For each scenario, when all players are in a group display a graphic and statistics from wandering, and announe them audibly. Game resets.
# TODO: For K-2, implement 2 people in opposite corners, who wander randomly. Count each move for each person. Basically the default scenario for functions.
# TODO: For 3-5, grid size can be set manually, which can now be rectangular. 2, 3 or 4 people, can be placed anywhere. Can play and replay multiple times, and display stats like longest run, shortest, average etc.
# TODO: For 6-8, Students are meant to run experiments to find how average runs vary with different sizes and shapes of grids, will need run-to-run tracking like 3-5. Also need different wandering protocols to use besides random.
# TODO: Change the appearance of two collided players to better represent they are both there, currently just 1 or 2 appears.
# TODO: Implement main to run in a loop for testing multiple times and multiple levels of complexity, needs to run until user ends it.
# TODO: Design document: Needs both specifications and software design, sample document is posted. Can be combined with user's guide.
# TODO: User's guide, simple instructions to tell users how to install and use the program.
# TODO: Finished code needs to be in exe file or binary, click to execute.
# TODO: Demo of code, given 20 minutes to demo our code.